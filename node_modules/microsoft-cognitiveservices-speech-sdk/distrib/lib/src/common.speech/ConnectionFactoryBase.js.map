{"version":3,"sources":["src/common.speech/ConnectionFactoryBase.ts"],"names":[],"mappings":"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","file":"ConnectionFactoryBase.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ServicePropertiesPropertyName,\r\n} from \"../common.speech/Exports.js\";\r\nimport { ConnectionRedirectEvent, Events, IConnection, IStringDictionary } from \"../common/Exports.js\";\r\nimport { PropertyId } from \"../sdk/Exports.js\";\r\nimport { AuthInfo, IConnectionFactory, RecognizerConfig } from \"./Exports.js\";\r\nimport { QueryParameterNames } from \"./QueryParameterNames.js\";\r\n\r\nexport abstract class ConnectionFactoryBase implements IConnectionFactory {\r\n\r\n    public static getHostSuffix(region: string): string {\r\n        if (!!region) {\r\n            if (region.toLowerCase().startsWith(\"china\")) {\r\n                return \".azure.cn\";\r\n            }\r\n            if (region.toLowerCase().startsWith(\"usgov\")) {\r\n                return \".azure.us\";\r\n            }\r\n        }\r\n        return \".microsoft.com\";\r\n    }\r\n\r\n    public abstract create(\r\n        config: RecognizerConfig,\r\n        authInfo: AuthInfo,\r\n        connectionId?: string): Promise<IConnection>;\r\n\r\n    protected setCommonUrlParams(\r\n        config: RecognizerConfig,\r\n        queryParams: IStringDictionary<string>,\r\n        endpoint: string): void {\r\n\r\n        const propertyIdToParameterMap: Map<number, string> = new Map([\r\n            [PropertyId.Speech_SegmentationSilenceTimeoutMs, QueryParameterNames.SegmentationSilenceTimeoutMs],\r\n            [PropertyId.SpeechServiceConnection_EnableAudioLogging, QueryParameterNames.EnableAudioLogging],\r\n            [PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, QueryParameterNames.EndSilenceTimeoutMs],\r\n            [PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, QueryParameterNames.InitialSilenceTimeoutMs],\r\n            [PropertyId.SpeechServiceResponse_PostProcessingOption, QueryParameterNames.Postprocessing],\r\n            [PropertyId.SpeechServiceResponse_ProfanityOption, QueryParameterNames.Profanity],\r\n            [PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, QueryParameterNames.EnableWordLevelTimestamps],\r\n            [PropertyId.SpeechServiceResponse_StablePartialResultThreshold, QueryParameterNames.StableIntermediateThreshold],\r\n        ]);\r\n\r\n        propertyIdToParameterMap.forEach((parameterName: string, propertyId: PropertyId): void => {\r\n            this.setUrlParameter(propertyId, parameterName, config, queryParams, endpoint);\r\n        });\r\n\r\n\r\n        const serviceProperties: IStringDictionary<string> = JSON.parse(config.parameters.getProperty(ServicePropertiesPropertyName, \"{}\")) as IStringDictionary<string>;\r\n\r\n        Object.keys(serviceProperties).forEach((value: string): void => {\r\n            queryParams[value] = serviceProperties[value];\r\n        });\r\n    }\r\n\r\n    protected setUrlParameter(\r\n        propId: PropertyId,\r\n        parameterName: string,\r\n        config: RecognizerConfig,\r\n        queryParams: IStringDictionary<string>,\r\n        endpoint: string): void {\r\n\r\n        const value: string = config.parameters.getProperty(propId, undefined);\r\n\r\n        // FIXME: The .search() check will incorrectly match parameter name anywhere in the string\r\n        //        including e.g. the path portion, or even as a substring of other query parameters\r\n        if (value && (!endpoint || endpoint.search(parameterName) === -1)) {\r\n            queryParams[parameterName] = value.toLocaleLowerCase();\r\n        }\r\n    }\r\n\r\n    public static async getRedirectUrlFromEndpoint(endpoint: string): Promise<string> {\r\n        // make a rest call to the endpoint to get the redirect url\r\n        const redirectUrl: URL = new URL(endpoint);\r\n        redirectUrl.protocol = \"https:\";\r\n        redirectUrl.port = \"443\";\r\n        const params: URLSearchParams = redirectUrl.searchParams;\r\n        params.append(\"GenerateRedirectResponse\", \"true\");\r\n\r\n        const redirectedUrlString: string = redirectUrl.toString();\r\n        Events.instance.onEvent(new ConnectionRedirectEvent(\"\", redirectedUrlString, undefined, \"ConnectionFactoryBase: redirectUrl request\"));\r\n\r\n        const redirectResponse: Response = await fetch(redirectedUrlString);\r\n\r\n        if (redirectResponse.status !== 200) {\r\n            return endpoint;\r\n        }\r\n\r\n        // Fix: properly read the response text\r\n        const redirectUrlString = await redirectResponse.text();\r\n\r\n        Events.instance.onEvent(new ConnectionRedirectEvent(\"\", redirectUrlString, endpoint, \"ConnectionFactoryBase: redirectUrlString\"));\r\n\r\n        try {\r\n            // Validate the URL before returning\r\n            return new URL(redirectUrlString.trim()).toString();\r\n        } catch (error) {\r\n            return endpoint; // Return original endpoint if the redirect URL is invalid\r\n        }\r\n    }\r\n\r\n}\r\n"]}